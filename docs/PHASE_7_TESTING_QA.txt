================================================================================
PHASE 7: COMPREHENSIVE TESTING & QUALITY ASSURANCE
Complete Testing Strategy for Production Readiness
================================================================================

STATUS: Implementation Ready
Estimated Duration: 20-25 hours
Priority: CRITICAL
Impact: Code quality, reliability, user trust

================================================================================
OVERVIEW
================================================================================

This phase establishes comprehensive testing across all layers:
unit tests, integration tests, end-to-end tests, performance tests,
security tests, and user acceptance testing (UAT).

Current State:
  • 45 services refactored ✅
  • 5 test suites created ✅
  • MongoDB Atlas verified ✅
  • Phase 4-6 documented ✅

Target State:
  • >90% code coverage
  • All tests passing
  • Load tested at 1000 concurrent users
  • Security vulnerabilities: 0
  • UAT approved
  • Zero critical bugs

================================================================================
PART 1: UNIT TESTING STRATEGY
================================================================================

1.1 Service Layer Unit Tests

Create: backend/tests/services/user.service.test.js
```javascript
const assert = require('assert');
const { createUser, getUserById, updateUser, deleteUser } = require('../../services/userService');
const User = require('../../models/User');

describe('UserService', () => {
  const mockUser = {
    email: 'test@example.com',
    username: 'testuser',
    password: 'HashedPassword123!',
    role: 'user'
  };

  describe('createUser', () => {
    it('should create a new user successfully', async () => {
      const user = await createUser(mockUser);
      assert(user._id);
      assert.equal(user.email, mockUser.email);
    });

    it('should reject duplicate email', async () => {
      try {
        await createUser(mockUser);
        await createUser(mockUser);
        assert.fail('Should have thrown');
      } catch (error) {
        assert(error.message.includes('duplicate'));
      }
    });

    it('should hash password', async () => {
      const user = await createUser(mockUser);
      assert.notEqual(user.password, mockUser.password);
    });
  });

  describe('getUserById', () => {
    it('should return user by ID', async () => {
      const created = await createUser(mockUser);
      const fetched = await getUserById(created._id);
      assert.equal(fetched._id.toString(), created._id.toString());
    });

    it('should return null for non-existent ID', async () => {
      const user = await getUserById('507f1f77bcf86cd799439011');
      assert.equal(user, null);
    });
  });

  describe('updateUser', () => {
    it('should update user fields', async () => {
      const created = await createUser(mockUser);
      const updated = await updateUser(created._id, { username: 'newname' });
      assert.equal(updated.username, 'newname');
    });

    it('should not update password field directly', async () => {
      const created = await createUser(mockUser);
      const updated = await updateUser(created._id, { password: 'NewPass123!' });
      // Password should not be updated through this method
      assert.notEqual(updated.password, 'NewPass123!');
    });
  });

  describe('deleteUser', () => {
    it('should delete user by ID', async () => {
      const created = await createUser(mockUser);
      await deleteUser(created._id);
      const fetched = await getUserById(created._id);
      assert.equal(fetched, null);
    });
  });
});
```

1.2 Mongoose Model Tests

Create: backend/tests/models/user.model.test.js
```javascript
const assert = require('assert');
const User = require('../../models/User');

describe('User Model', () => {
  describe('Validation', () => {
    it('should require email', async () => {
      const user = new User({ username: 'test' });
      try {
        await user.validate();
        assert.fail('Should require email');
      } catch (error) {
        assert(error.errors.email);
      }
    });

    it('should validate email format', async () => {
      const user = new User({
        email: 'invalid-email',
        username: 'test'
      });
      try {
        await user.validate();
        assert.fail('Should reject invalid email');
      } catch (error) {
        assert(error.errors.email);
      }
    });

    it('should enforce unique email', async () => {
      const email = 'unique@example.com';
      await User.create({ email, username: 'user1', password: 'Pass123!' });
      
      try {
        await User.create({ email, username: 'user2', password: 'Pass123!' });
        assert.fail('Should enforce unique email');
      } catch (error) {
        assert(error.code === 11000); // MongoDB duplicate key error
      }
    });
  });

  describe('Indexes', () => {
    it('should have email index', async () => {
      const indexes = await User.collection.getIndexes();
      assert(indexes['email_1']);
    });

    it('should have username index', async () => {
      const indexes = await User.collection.getIndexes();
      assert(indexes['username_1']);
    });
  });
});
```

1.3 Run Unit Tests

Command:
```bash
npm test -- --testPathPattern="tests/services|tests/models"
```

Expected: >95% of unit tests passing

================================================================================
PART 2: INTEGRATION TESTING STRATEGY
================================================================================

2.1 API Endpoint Tests

Create: backend/tests/api/users.api.test.js
```javascript
const request = require('supertest');
const app = require('../../server');
const User = require('../../models/User');
const { generateToken } = require('../../middleware/jwt');

describe('User API Endpoints', () => {
  let token;
  let userId;

  before(async () => {
    const user = await User.create({
      email: 'api@test.com',
      username: 'apitest',
      password: 'HashedPass123!'
    });
    userId = user._id;
    token = generateToken(userId, 'user');
  });

  describe('POST /api/users', () => {
    it('should create user with valid data', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({
          email: 'new@test.com',
          username: 'newuser',
          password: 'NewPass123!'
        });

      assert.equal(response.status, 201);
      assert(response.body._id);
    });

    it('should reject invalid email', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({
          email: 'invalid',
          username: 'test',
          password: 'Pass123!'
        });

      assert.equal(response.status, 400);
    });
  });

  describe('GET /api/users/:id', () => {
    it('should return user by ID with auth', async () => {
      const response = await request(app)
        .get(`/api/users/${userId}`)
        .set('Authorization', `Bearer ${token}`);

      assert.equal(response.status, 200);
      assert.equal(response.body.email, 'api@test.com');
    });

    it('should reject without auth token', async () => {
      const response = await request(app)
        .get(`/api/users/${userId}`);

      assert.equal(response.status, 401);
    });
  });

  describe('PUT /api/users/:id', () => {
    it('should update user', async () => {
      const response = await request(app)
        .put(`/api/users/${userId}`)
        .set('Authorization', `Bearer ${token}`)
        .send({ username: 'updated' });

      assert.equal(response.status, 200);
      assert.equal(response.body.username, 'updated');
    });

    it('should prevent updating own role', async () => {
      const response = await request(app)
        .put(`/api/users/${userId}`)
        .set('Authorization', `Bearer ${token}`)
        .send({ role: 'admin' });

      assert.equal(response.body.role, 'user'); // Should remain unchanged
    });
  });

  describe('DELETE /api/users/:id', () => {
    it('should delete user', async () => {
      const user = await User.create({
        email: 'delete@test.com',
        username: 'delete',
        password: 'Pass123!'
      });

      const response = await request(app)
        .delete(`/api/users/${user._id}`)
        .set('Authorization', `Bearer ${token}`);

      assert.equal(response.status, 204);
    });
  });
});
```

2.2 Run Integration Tests

Command:
```bash
npm test -- --testPathPattern="tests/api"
```

Expected: >90% of integration tests passing

================================================================================
PART 3: END-TO-END TESTING WITH CYPRESS
================================================================================

3.1 Cypress Setup

Install:
```bash
npm install --save-dev cypress
```

Configure: cypress.config.js
```javascript
module.exports = {
  e2e: {
    baseUrl: 'http://localhost:3000',
    specPattern: 'cypress/e2e/**/*.cy.js',
    supportFile: 'cypress/support/e2e.js',
    video: false,
    screenshotOnRunFailure: true
  }
};
```

3.2 E2E Test Examples

Create: cypress/e2e/auth.cy.js
```javascript
describe('Authentication Flow', () => {
  beforeEach(() => {
    cy.visit('/login');
  });

  it('should login with valid credentials', () => {
    cy.get('[data-testid="email-input"]').type('test@example.com');
    cy.get('[data-testid="password-input"]').type('TestPass123!');
    cy.get('[data-testid="login-button"]').click();
    
    cy.url().should('include', '/dashboard');
    cy.get('[data-testid="user-menu"]').should('be.visible');
  });

  it('should show error on invalid credentials', () => {
    cy.get('[data-testid="email-input"]').type('test@example.com');
    cy.get('[data-testid="password-input"]').type('WrongPassword');
    cy.get('[data-testid="login-button"]').click();
    
    cy.get('[data-testid="error-message"]').should('contain', 'Invalid credentials');
  });

  it('should logout user', () => {
    // Login first
    cy.login('test@example.com', 'TestPass123!');
    
    // Logout
    cy.get('[data-testid="user-menu"]').click();
    cy.get('[data-testid="logout-button"]').click();
    
    cy.url().should('include', '/login');
  });
});

describe('Sadhana Management', () => {
  beforeEach(() => {
    cy.login('test@example.com', 'TestPass123!');
    cy.visit('/sadhanas');
  });

  it('should create new sadhana', () => {
    cy.get('[data-testid="create-button"]').click();
    cy.get('[data-testid="name-input"]').type('Morning Meditation');
    cy.get('[data-testid="type-select"]').select('meditation');
    cy.get('[data-testid="submit-button"]').click();
    
    cy.get('[data-testid="success-message"]').should('contain', 'Created');
    cy.get('[data-testid="sadhana-list"]').should('contain', 'Morning Meditation');
  });

  it('should edit sadhana', () => {
    cy.get('[data-testid="sadhana-item"]').first().click();
    cy.get('[data-testid="edit-button"]').click();
    cy.get('[data-testid="name-input"]').clear().type('Updated Meditation');
    cy.get('[data-testid="submit-button"]').click();
    
    cy.get('[data-testid="success-message"]').should('contain', 'Updated');
  });

  it('should delete sadhana', () => {
    cy.get('[data-testid="sadhana-item"]').first().within(() => {
      cy.get('[data-testid="delete-button"]').click();
    });
    
    cy.get('[data-testid="confirm-button"]').click();
    cy.get('[data-testid="success-message"]').should('contain', 'Deleted');
  });
});
```

3.3 Run E2E Tests

Command:
```bash
npx cypress open
# or
npx cypress run
```

Expected: All critical user flows tested and passing

================================================================================
PART 4: PERFORMANCE TESTING
================================================================================

4.1 Load Testing with k6

Create: tests/performance/load-test.js
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 },   // Ramp to 100 users
    { duration: '5m', target: 100 },   // Stay at 100
    { duration: '2m', target: 200 },   // Ramp to 200
    { duration: '5m', target: 200 },   // Stay at 200
    { duration: '2m', target: 0 },     // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500', 'p(99)<1000'],
    http_req_failed: ['rate<0.1'],
  },
};

export default function () {
  let response = http.get('http://localhost:3004/api/health');
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });

  sleep(1);
}
```

Run:
```bash
k6 run tests/performance/load-test.js
```

Expected:
  • Handle 1000+ concurrent users
  • P95 latency < 500ms
  • P99 latency < 1000ms
  • Error rate < 0.1%

================================================================================
PART 5: SECURITY TESTING
================================================================================

5.1 OWASP Dependency Check

Install:
```bash
npm install --save-dev audit
```

Run:
```bash
npm audit
npm audit fix
```

5.2 Security Headers Test

Create: tests/security/headers.test.js
```javascript
const request = require('supertest');
const app = require('../../server');

describe('Security Headers', () => {
  it('should have X-Content-Type-Options header', async () => {
    const response = await request(app).get('/api/health');
    assert(response.headers['x-content-type-options']);
  });

  it('should have X-Frame-Options header', async () => {
    const response = await request(app).get('/api/health');
    assert(response.headers['x-frame-options']);
  });

  it('should have Content-Security-Policy header', async () => {
    const response = await request(app).get('/api/health');
    assert(response.headers['content-security-policy']);
  });

  it('should not expose X-Powered-By', async () => {
    const response = await request(app).get('/api/health');
    assert(!response.headers['x-powered-by']);
  });
});
```

5.3 OWASP ZAP Testing

```bash
docker run -u zap -p 8080:8080 -i owasp/zap2docker-stable zap-baseline.py \
  -t http://localhost:3004/api/health
```

================================================================================
PART 6: TEST EXECUTION CHECKLIST
================================================================================

Unit Tests:
  ☐ All service tests passing (>95%)
  ☐ All model validation tests passing
  ☐ All utility function tests passing
  ☐ Code coverage > 90%

Integration Tests:
  ☐ All API endpoint tests passing
  ☐ Authentication flow working
  ☐ Database operations verified
  ☐ Error handling validated

E2E Tests:
  ☐ Login/Logout flow working
  ☐ Create/Read/Update/Delete operations verified
  ☐ User workflows tested
  ☐ Navigation flows validated

Performance Tests:
  ☐ Load test: 1000 concurrent users
  ☐ Response times acceptable (p95 < 500ms)
  ☐ Error rate < 0.1%
  ☐ Memory usage stable

Security Tests:
  ☐ No critical vulnerabilities
  ☐ No medium vulnerabilities
  ☐ Security headers present
  ☐ OWASP Top 10 compliance

================================================================================
PART 7: BUG TRACKING & FIXES
================================================================================

Bug Report Template:
```
Title: [AREA] Brief description
Severity: Critical/High/Medium/Low
Steps to Reproduce:
1. Step 1
2. Step 2
3. Step 3
Expected Behavior: ...
Actual Behavior: ...
Environment: ...
Attachments: (screenshots/logs)
```

Fix Priority:
  1. Critical bugs (system down, data loss)
  2. High priority (major features broken)
  3. Medium priority (features degraded)
  4. Low priority (cosmetic, enhancement)

================================================================================
PART 8: USER ACCEPTANCE TESTING (UAT)
================================================================================

UAT Sign-off Requirements:
  ☐ All features work as specified
  ☐ Performance is acceptable
  ☐ UI/UX is intuitive
  ☐ Data is accurate
  ☐ No critical issues found
  ☐ User can complete all workflows

UAT Participants:
  • Product Owner
  • End Users (3-5 representatives)
  • QA Lead
  • Technical Lead

UAT Timeline:
  • Preparation: 1 day
  • Testing: 3-5 days
  • Bug fixes: 2-3 days
  • Final verification: 1 day

================================================================================
TEST EXECUTION TIMELINE
================================================================================

Week 1: Setup & Unit Tests (8 hours)
  • Test framework setup
  • Unit tests for all services
  • Model validation tests
  • Target: 90%+ coverage

Week 2: Integration & E2E Tests (8 hours)
  • API integration tests
  • E2E test scenarios
  • Database integration
  • Target: 100% critical paths

Week 3: Performance & Security (5 hours)
  • Load testing
  • Security vulnerability scan
  • Performance optimization
  • Target: All thresholds met

Week 4: UAT & Bug Fixes (4 hours)
  • User acceptance testing
  • Bug fixes
  • Final verification
  • Target: Zero critical bugs

Total: 25 hours

================================================================================
EXPECTED RESULTS
================================================================================

Quality Metrics:
  • Code Coverage: >90%
  • Test Pass Rate: >99%
  • Critical Bugs: 0
  • High Priority Bugs: 0
  • Medium Priority Bugs: <5

Performance:
  • P95 Latency: <500ms
  • P99 Latency: <1000ms
  • 99th percentile response time: <1s
  • Concurrent Users: 1000+

Security:
  • Vulnerabilities: 0 Critical, 0 High
  • Security Score: A+
  • OWASP Compliance: 10/10

User Acceptance:
  • UAT Sign-off: Approved
  • User Satisfaction: >95%
  • Feature Completeness: 100%

================================================================================

Status: Implementation Ready
Next: Phase 8 - Deployment & DevOps

================================================================================
