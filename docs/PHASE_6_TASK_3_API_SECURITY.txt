================================================================================
PHASE 6: TASK 3 - API SECURITY & RATE LIMITING
Comprehensive API Security and DDoS Protection
================================================================================

DATE: December 5, 2025
TASK: 3 of 8
STATUS: ✅ COMPLETE
DURATION: 4-5 hours

================================================================================
TASK 3 OVERVIEW
================================================================================

OBJECTIVE: Implement comprehensive API security including rate limiting,
           input validation, security headers, and DDoS protection.

DELIVERABLES:
  ✅ Rate Limiting Service (358 lines)
  ✅ Rate Limiting Middleware (239 lines)
  ✅ Security Headers Middleware (328 lines)
  ✅ API Key Management Service (283 lines)
  ✅ API Security Tests (356 lines)
  ✅ Complete Documentation (this file)

TOTAL TASK CODE: 1,564 lines

================================================================================
API SECURITY ARCHITECTURE
================================================================================

SECURITY LAYERS:

1. IP-BASED RATE LIMITING
   ├─ DDoS Protection
   ├─ Suspicious IP detection
   ├─ Blacklist/whitelist
   └─ Automatic blocking

2. USER/ROLE-BASED RATE LIMITING
   ├─ Public: 100 req/min
   ├─ Guest: 300 req/min
   ├─ User: 1,000 req/min
   ├─ Mentor: 2,000 req/min
   ├─ Admin: 5,000 req/min
   └─ Super Admin: 10,000 req/min

3. API KEY RATE LIMITING
   ├─ Per-key limits
   ├─ Usage tracking
   ├─ Permission enforcement
   └─ Revocation support

4. INPUT VALIDATION
   ├─ HTML sanitization
   ├─ SQL/NoSQL injection prevention
   ├─ Size limits
   └─ Type validation

5. SECURITY HEADERS
   ├─ CSP (Content Security Policy)
   ├─ HSTS (HTTP Strict Transport Security)
   ├─ X-Frame-Options
   ├─ X-Content-Type-Options
   └─ Referrer-Policy

6. CORS PROTECTION
   ├─ Origin whitelisting
   ├─ Method restriction
   ├─ Header validation
   └─ Credential handling

================================================================================
RATE LIMITING SERVICE
================================================================================

FILE: backend/services/rateLimitService.js (358 lines)

CLASSES PROVIDED:

1. RateLimiter
   Purpose: Token bucket algorithm for rate limiting
   
   Methods:
     • isAllowed(key, role, weight) - Check if request allowed
     • getStatus(key) - Get current bucket status
     • reset(key) - Reset specific key
     • resetAll() - Reset all limits
     • cleanupExpired() - Auto-cleanup expired buckets
     • getStats() - Get statistics
     • setCustomLimit(key, max, window) - Custom limit

   Features:
     • Token bucket algorithm
     • Auto-refill tokens
     • Multiple roles support
     • Custom limits per key
     • Automatic cleanup
     • Request tracking

2. IPRateLimiter
   Purpose: IP-based rate limiting for DDoS protection
   
   Methods:
     • isLimited(ip) - Check if IP limited
     • blacklistIP(ip) - Add to blacklist
     • unblacklistIP(ip) - Remove from blacklist
     • whitelistIP(ip) - Add to whitelist
     • getSuspiciousIPs() - Get suspicious IPs
     • getStats() - Get statistics

   Features:
     • IP-based limiting
     • Blacklist/whitelist support
     • Suspicious activity tracking
     • Automatic cleanup
     • Configurable thresholds

DEFAULT LIMITS BY ROLE:

Role          | Requests/min | Window
--------------|--------------|--------
public        |     100      | 60s
guest         |     300      | 60s
user          |   1,000      | 60s
mentor        |   2,000      | 60s
admin         |   5,000      | 60s
superadmin    |  10,000      | 60s

USAGE EXAMPLE:

```javascript
const { getRateLimiter } = require('./services/rateLimitService');
const limiter = getRateLimiter();

// Check if request allowed
const result = limiter.isAllowed(
  'user:123',  // key
  'user',      // role
  1            // weight (default: 1)
);

if (!result.allowed) {
  return res.status(429).json({
    error: 'Rate limit exceeded',
    retryAfter: result.retryAfter,
  });
}

// Request allowed
res.set('RateLimit-Remaining', result.remaining);
// ... handle request
```

================================================================================
RATE LIMITING MIDDLEWARE
================================================================================

FILE: backend/middleware/rateLimitMiddleware.js (239 lines)

MIDDLEWARE FUNCTIONS:

1. rateLimitByRole(options)
   Purpose: Rate limit by user role
   Usage: app.use(rateLimitByRole())
   
   Features:
     • Automatic role detection
     • Per-user tracking
     • Dynamic limits by role
     • Rate limit headers

2. ipRateLimit(options)
   Purpose: DDoS protection via IP limiting
   Usage: app.use(ipRateLimit())
   
   Features:
     • IP tracking
     • Burst detection
     • Suspicious activity logging
     • Automatic blocking

3. rateLimitEndpoint(endpoint, limits)
   Purpose: Specific endpoint limits
   Usage: app.get('/api/expensive', rateLimitEndpoint('expensive', { max: 10, window: 60 }), handler)
   
   Features:
     • Per-endpoint limits
     • Override global limits
     • Custom thresholds

4. apiKeyRateLimit(validator, options)
   Purpose: Rate limit by API key
   Usage: app.use(apiKeyRateLimit(validateKey))
   
   Features:
     • API key validation
     • Per-key limits
     • Usage tracking

5. burstProtection(options)
   Purpose: Prevent request spikes
   Usage: app.use(burstProtection())
   
   Features:
     • Burst detection
     • Spike threshold
     • Automatic throttling

6. monitorRateLimits(threshold)
   Purpose: Monitor approaching limits
   Usage: app.use(monitorRateLimits(0.8))
   
   Features:
     • Usage monitoring
     • Warning logs
     • Threshold tracking

INTEGRATION EXAMPLE:

```javascript
const {
  rateLimitByRole,
  ipRateLimit,
  burstProtection,
} = require('./middleware/rateLimitMiddleware');

// Global middleware
app.use(ipRateLimit()); // DDoS protection
app.use(rateLimitByRole()); // Per-user limiting
app.use(burstProtection()); // Burst protection

// Endpoint-specific
app.post('/api/expensive',
  rateLimitEndpoint('expensive', { max: 10, window: 60 }),
  handler
);
```

RESPONSE HEADERS:

```
RateLimit-Limit: 1000
RateLimit-Remaining: 995
RateLimit-Reset: 2025-12-05T18:05:00Z
```

RATE LIMIT EXCEEDED RESPONSE:

```json
{
  "error": "Too Many Requests",
  "message": "Rate limit exceeded. Please try again later.",
  "retryAfter": 45,
  "resetTime": "2025-12-05T18:05:00Z"
}
```

================================================================================
SECURITY HEADERS MIDDLEWARE
================================================================================

FILE: backend/middleware/securityHeadersMiddleware.js (328 lines)

MIDDLEWARE FUNCTIONS:

1. securityHeaders(options)
   Purpose: Apply security headers
   
   Headers Applied:
     • Content-Security-Policy
     • X-Content-Type-Options: nosniff
     • X-XSS-Protection: 1; mode=block
     • X-Frame-Options: DENY
     • Referrer-Policy: strict-origin-when-cross-origin
     • Permissions-Policy (disable dangerous features)
     • Strict-Transport-Security (HSTS)

2. corsMiddleware(options)
   Purpose: CORS configuration
   
   Features:
     • Origin whitelisting
     • Method restriction
     • Header validation
     • Preflight handling
     • Credentials support

3. inputSanitization(options)
   Purpose: Sanitize input data
   
   Features:
     • HTML escaping
     • Special character removal
     • Length limiting
     • Recursive sanitization

4. preventNoSQLInjection()
   Purpose: Prevent MongoDB injection
   
   Features:
     • Operator detection ($ne, $gt, etc.)
     • Recursive checking
     • Type validation

5. validateContentType(options)
   Purpose: Validate request content type
   
   Features:
     • Whitelist enforcement
     • 415 error on mismatch

6. limitRequestSize(maxSize)
   Purpose: Limit request body size
   
   Features:
     • Size validation
     • Human-readable sizes (10mb, 1gb)
     • 413 error on exceed

7. noCache()
   Purpose: Disable caching for sensitive endpoints
   
   Features:
     • Cache-Control headers
     • Pragma headers
     • Expires header

8. httpsRedirect()
   Purpose: Redirect HTTP to HTTPS
   
   Features:
     • Automatic redirection
     • Production-ready

INTEGRATION EXAMPLE:

```javascript
const {
  securityHeaders,
  corsMiddleware,
  inputSanitization,
  preventNoSQLInjection,
  limitRequestSize,
  noCache,
} = require('./middleware/securityHeadersMiddleware');

// Apply globally
app.use(securityHeaders({ https: true }));
app.use(corsMiddleware({
  allowedOrigins: ['http://localhost:5173'],
}));
app.use(inputSanitization({ maxLength: 10000 }));
app.use(preventNoSQLInjection());
app.use(limitRequestSize('10mb'));

// Sensitive endpoints
app.get('/api/auth/refresh', noCache(), handler);
```

SECURITY HEADERS SENT:

```
Content-Security-Policy: default-src 'self'; script-src 'self'
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
X-Frame-Options: DENY
Referrer-Policy: strict-origin-when-cross-origin
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

================================================================================
API KEY MANAGEMENT
================================================================================

FILE: backend/services/apiKeyService.js (283 lines)

CLASS: APIKeyService

METHODS:

1. generateKey(clientName, options)
   Generate new API key
   Returns: { key, keyId, clientName, createdAt }

2. validateKey(key)
   Validate API key format and signature
   Returns: { keyId, clientName, permissions } or null

3. getKeyInfo(keyId)
   Get key metadata without secret
   Returns: Key info or null

4. listKeys(options)
   List all keys (safe view)
   Returns: Array of key metadata

5. revokeKey(keyId)
   Revoke API key
   Returns: boolean

6. regenerateKey(keyId)
   Revoke old and generate new
   Returns: New key info

7. updateKeyPermissions(keyId, permissions)
   Update key permissions
   Returns: boolean

8. updateRateLimit(keyId, rateLimit)
   Update rate limit for key
   Returns: boolean

9. hasPermission(keyId, permission)
   Check if key has permission
   Returns: boolean

10. getStats(keyId)
    Get usage statistics
    Returns: { requestCount, lastUsedAt, requestsPerDay }

11. getAllStats()
    Get all keys statistics
    Returns: Array of stats

12. deleteKey(keyId)
    Hard delete key
    Returns: boolean

13. cleanupInactiveKeys(days)
    Delete revoked keys older than X days
    Returns: Count deleted

KEY FORMAT:

```
keyid:keysecret
e.g., abc123def456:xyz789uvw012
```

KEY SECURITY:

✅ Features:
  • 32-byte random secrets (64 hex chars)
  • Constant-time comparison
  • No exposure of secrets in responses
  • Revocation support
  • Permission-based access
  • Usage tracking

KEY GENERATION EXAMPLE:

```javascript
const { getAPIKeyService } = require('./services/apiKeyService');
const keyService = getAPIKeyService();

// Generate key
const newKey = keyService.generateKey('My App', {
  rateLimit: { requests: 1000, window: 60 },
  permissions: ['read:sadhana', 'read:books'],
});

console.log('API Key:', newKey.key);
// Output: abc123def456:xyz789uvw012

// Return to user (only shown once!)
```

API KEY VALIDATION EXAMPLE:

```javascript
const { getAPIKeyService } = require('./services/apiKeyService');
const keyService = getAPIKeyService();

const apiKey = req.headers['x-api-key'];
const keyData = keyService.validateKey(apiKey);

if (!keyData) {
  return res.status(401).json({ error: 'Invalid API key' });
}

// Use keyData.permissions for authorization
```

================================================================================
API SECURITY TESTS
================================================================================

TEST FILE: src/__tests__/apiSecurity.test.ts (356 lines)

TEST SUITES:

1. Rate Limiting Tests (5 tests)
   ✅ Requests within limit allowed
   ✅ Requests exceeding limit rejected
   ✅ Limit reset after window expires
   ✅ Different limits by role
   ✅ Rate limit headers included

2. IP Rate Limiting Tests (4 tests)
   ✅ IP tracking
   ✅ DDoS pattern detection
   ✅ IP blacklisting
   ✅ IP whitelisting

3. Input Validation Tests (5 tests)
   ✅ HTML sanitization
   ✅ SQL injection prevention
   ✅ NoSQL injection prevention
   ✅ String length limiting
   ✅ Type validation

4. Security Headers Tests (6 tests)
   ✅ Content-Security-Policy
   ✅ MIME type sniffing prevention
   ✅ X-Frame-Options
   ✅ XSS protection
   ✅ HSTS support
   ✅ Server info hiding

5. CORS Security Tests (4 tests)
   ✅ Origin whitelisting
   ✅ Preflight requests
   ✅ Access-Control headers
   ✅ Unauthorized origin rejection

6. API Key Security Tests (7 tests)
   ✅ Secure key generation
   ✅ Key format validation
   ✅ Constant-time comparison
   ✅ Rate limit application
   ✅ Usage tracking
   ✅ Key revocation
   ✅ Key regeneration

7. Request Size Limiting Tests (3 tests)
   ✅ Body size limits
   ✅ Oversized request rejection
   ✅ Content-Length checking

8. Content Type Validation Tests (3 tests)
   ✅ Valid content type acceptance
   ✅ Invalid content type rejection
   ✅ 415 error on mismatch

9. Burst Protection Tests (3 tests)
   ✅ Burst detection
   ✅ Burst throttling
   ✅ Per-user tracking

10. Error Handling Tests (2 tests)
    ✅ No sensitive details exposed
    ✅ Security events logged

Total: 42 test cases ✅

================================================================================
IMPLEMENTATION GUIDE
================================================================================

STEP 1: Global Middleware Setup

```javascript
const express = require('express');
const {
  securityHeaders,
  corsMiddleware,
  inputSanitization,
  preventNoSQLInjection,
  limitRequestSize,
} = require('./middleware/securityHeadersMiddleware');
const {
  ipRateLimit,
  rateLimitByRole,
  burstProtection,
  monitorRateLimits,
} = require('./middleware/rateLimitMiddleware');

const app = express();

// Security headers (early in chain)
app.use(securityHeaders({ https: process.env.NODE_ENV === 'production' }));

// CORS
app.use(corsMiddleware());

// IP-based rate limiting (DDoS protection)
app.use(ipRateLimit());

// Burst protection
app.use(burstProtection());

// Request validation
app.use(limitRequestSize('10mb'));
app.use(express.json());
app.use(inputSanitization());
app.use(preventNoSQLInjection());

// User/role-based rate limiting
app.use(rateLimitByRole());

// Monitoring
app.use(monitorRateLimits(0.8));
```

STEP 2: Protected Route Setup

```javascript
const { requirePermission } = require('./middleware/rbacMiddleware');
const { rateLimitEndpoint } = require('./middleware/rateLimitMiddleware');

// Regular endpoint
app.get('/api/users',
  validateToken,
  requirePermission('user:read'),
  userHandler
);

// Expensive endpoint with custom limit
app.post('/api/export',
  validateToken,
  rateLimitEndpoint('export', { max: 5, window: 3600 }),
  exportHandler
);
```

STEP 3: API Key Validation

```javascript
const { getAPIKeyService } = require('./services/apiKeyService');
const { apiKeyRateLimit } = require('./middleware/rateLimitMiddleware');

const keyService = getAPIKeyService();

app.use(apiKeyRateLimit((apiKey) => {
  return keyService.validateKey(apiKey);
}));
```

================================================================================
SECURITY BEST PRACTICES
================================================================================

✅ DO:
  • Use HTTPS in production
  • Enable all security headers
  • Validate all inputs
  • Implement rate limiting at multiple levels
  • Use strong API secrets (32+ bytes)
  • Rotate secrets regularly
  • Log security events
  • Monitor for suspicious activity
  • Keep dependencies updated
  • Test security regularly

❌ DON'T:
  • Expose error details to users
  • Trust client-side validation
  • Use weak rate limits
  • Hardcode secrets
  • Skip input validation
  • Expose API keys in logs
  • Use HTTP in production
  • Trust untrusted origins
  • Disable CORS without reason
  • Ignore security warnings

================================================================================
TROUBLESHOOTING
================================================================================

ISSUE: "Rate limit exceeded" when legitimate

Causes:
  • Limit too low for use case
  • Multiple requests from same user
  • API key not being used

Solution:
  1. Check configured limits
  2. Verify user role
  3. Check if API key has higher limit
  4. Contact admin for limit increase

---

ISSUE: CORS errors in browser

Causes:
  • Origin not whitelisted
  • Method not allowed
  • Missing headers

Solution:
  1. Add origin to allowedOrigins
  2. Add method to allowedMethods
  3. Add header to allowedHeaders
  4. Check browser console for specifics

---

ISSUE: Input being rejected

Causes:
  • Contains special characters
  • Exceeds length limit
  • Detected as injection attempt

Solution:
  1. Remove HTML/special characters
  2. Reduce string length
  3. Contact admin if legitimate

================================================================================
PHASE 6 TASK 3 COMPLETION SUMMARY
================================================================================

DELIVERABLES:
  ✅ Rate Limiting Service (358 lines)
     • Token bucket algorithm
     • Role-based limits
     • IP tracking
     • DDoS protection

  ✅ Rate Limiting Middleware (239 lines)
     • Global rate limiting
     • IP-based limiting
     • Burst protection
     • Endpoint-specific limits

  ✅ Security Headers Middleware (328 lines)
     • Security headers
     • CORS configuration
     • Input sanitization
     • NoSQL injection prevention

  ✅ API Key Management (283 lines)
     • Key generation
     • Key validation
     • Usage tracking
     • Permission management

  ✅ API Security Tests (356 lines)
     • 42 test cases
     • Full coverage
     • All scenarios

  ✅ Complete Documentation (this file)

TOTAL PHASE 6 TASK 3: 1,564 lines

VERIFICATION:
  ✅ All code compiles without errors
  ✅ All 42 tests passing
  ✅ Multiple security layers implemented
  ✅ DDoS protection ready
  ✅ OWASP best practices followed
  ✅ Production-ready code

READY FOR: Phase 6 Task 4 - Data Encryption & Secure Storage

================================================================================
