# Theme Workflow Guide for SaadhanaBoard

This guide explains the complete lifecycle of themes in SaadhanaBoard: how to add themes, generate the backend manifest, manage availability in the admin UI, test, and deploy.

## 1. Introduction

SaadhanaBoard uses a folder-based theme system. Each theme lives in its own folder under `src/themes/` and exports a `ThemeDefinition` typed object. The frontend registry is the single source of truth for theme definitions. A build-time script extracts serializable metadata into `backend/data/theme-registry.json` which the backend uses to validate and enrich CMS records and power the admin UI.

Why this design?
- Modularity: each theme is isolated in its own folder.
- Type safety: TypeScript types ensure consistency across themes.
- Tree-shaking: static imports allow bundlers to include only used themes.
- Admin control: backend stores availability flags so admins can enable/disable themes without code changes.

## 2. Theme System Architecture

Sequence:
1. Developer creates a new theme under `src/themes/` with `index.ts` and `colors.ts` (and optionally `background.tsx` and `assets/`).
2. Developer registers the theme in `src/themes/index.ts`.
3. Developer runs `npm run themes:generate` (or `npm run build`) which runs the manifest script and writes `backend/data/theme-registry.json`.
4. Backend loads `theme-registry.json` at startup (or on demand) and merges metadata with the admin-controlled `backend/data/themes.json` availability overrides.
5. Admin UI calls the backend to list themes; admin toggles availability which persists to `backend/data/themes.json`.

## 3. Theme Folder Anatomy

Each theme folder typically contains:

- `index.ts` - Main export that provides metadata and a ThemeDefinition object.
- `colors.ts` - HSL color variables used by `applyThemeColors()`.
- `background.tsx` (optional) - Custom React background component for landing pages or special effects.
- `assets/` (optional) - Images/icons used by the theme.

Example structure:

```
src/themes/shiva/
  ├── index.ts
  ├── colors.ts
  ├── background.tsx (optional)
  └── assets/
```

### Example: Shiva theme (simplified)

```ts
// src/themes/shiva/index.ts
import { ThemeDefinition } from '../types';
import colors from './colors';

const metadata = {
  id: 'shiva',
  name: 'Shiva',
  description: 'Serene blue meditation theme',
  deity: 'Shiva',
  category: 'color-scheme',
  gradient: 'from-blue-900 via-indigo-700 to-purple-800'
};

const shiva: ThemeDefinition = {
  metadata,
  colors,
};

export default shiva;
```

### ThemeColors
Colors are defined in HSL string form (e.g. "210 30% 13%") to make programmatic adjustments easy.

A typical `colors.ts` exports an object with named CSS variables that match the ThemeColors type.

## 4. Adding a New Theme (Step-by-Step)

Step 1: Create the theme folder under `src/themes/` (use kebab-case id).

Step 2: Add `colors.ts` with required color variables (HSL format).

Step 3: Add `index.ts` with metadata and ThemeDefinition export. Include fields: `id`, `name`, `description`, `deity`, `category` ('landing'|'color-scheme'|'hybrid'), `isLandingPage`, `landingPagePath` (if landing).

Step 4: Register in `src/themes/index.ts`:
```ts
import lakshmi from './lakshmi';

export default [
  defaultTheme,
  shiva,
  mahakali,
  // ...
  lakshmi,
];
```

Step 5: Generate backend manifest:
```powershell
npm run themes:generate
```
The script writes `backend/data/theme-registry.json` used by the backend.

## 5. Custom Background Component

If your theme needs a special background, add `background.tsx` that exports a React component. In `index.ts`, reference it as `BackgroundComponent`.

Use React.lazy() if needed to lazily load heavy components.

## 6. Theme Assets

Create an `assets/` folder to keep images. Reference the public paths or import them in the theme definition.

## 7. Backend Availability Management

- `backend/data/theme-registry.json` is the serialized manifest (read-only; generated by the script).
- `backend/data/themes.json` is the admin-controlled overrides (available: boolean, colors overrides, notes).
- Backend merges registry metadata with overrides and returns themes to admin UI and consumers.

## 8. Admin Theme Management

Admins can toggle availability in the `/admin/themes` page. The UI calls backend endpoints to persist availability flags to `backend/data/themes.json`.

Admins cannot add code-level themes from UI; new themes must be added by developers and included in the manifest.

## 9. Theme Registry API (Frontend)

Common helpers available from `src/themes/index.ts`:

```ts
import { getThemeById, listThemes, getLandingPageThemes } from '@/themes';

const t = getThemeById('shiva');
const list = listThemes({ category: 'color-scheme' });
```

## 10. Theme Utilities

- `applyThemeColors(colors)` - sets CSS variables on `:root` for theme colors.
- `renderThemeIcon(theme, sizeClass)` - renders the theme icon.
- `getThemeWithFallback(id, registry)` - returns theme or default fallback.

## 11. Testing

- Frontend: `npm run dev`, open Appearance/Settings → select and test theme.
- Backend: `npm run themes:generate`, check `backend/data/theme-registry.json`, start backend, inspect `/api/admin/themes`.

## 12. Deployment

- Manifest generation runs during `npm run build` per `package.json` scripts.
- Ensure `backend/data/theme-registry.json` is deployed alongside backend.

## 13. Troubleshooting

See the "Troubleshooting" section in the main project docs for common issues.

## 14. Advanced Topics

- Consider dynamic loading for very large custom background components.
- For future user-created themes, implement server-side validation and a safe serialization format.

## 15. Quick Reference

- Theme definitions: `src/themes/<id>/`
- Manifest generator: `scripts/generate-theme-manifest.js`
- Backend manifest: `backend/data/theme-registry.json`
- Availability flags: `backend/data/themes.json`


---

If you'd like, I can add code snippets from the actual theme files (Shiva, Mahakali) into this guide. Otherwise the guide is a complete practical workflow you can follow immediately.
